WEBVTT

00:00.540 --> 00:03.630
So let's go ahead and see how we can test our API.

00:03.630 --> 00:10.890
So first let's run peach B unit inside Visual Studio the terminal and we can see that we have one outstanding

00:10.920 --> 00:14.090
error from our previous test that we have written.

00:14.310 --> 00:19.770
And it says that it cannot find no comments yet text with an exclamation point.

00:20.310 --> 00:25.590
So you might remember that we did this inside the post test BHP.

00:25.590 --> 00:26.910
So let's try to find it.

00:26.910 --> 00:28.980
Where do we actually verify that

00:32.000 --> 00:40.040
yes so the thing is that in our test we are checking for text with an exclamation point were actually

00:40.070 --> 00:45.580
what we are doing is after using their translations the text is a little bit different.

00:45.590 --> 00:49.190
So it should be like this one.

00:50.360 --> 00:57.020
So let's fix this one quickly save the changes and rerun tests again so everything is green.

00:57.170 --> 01:01.520
And now from this point we can create our first test for the API.

01:01.850 --> 01:09.260
So of course we can quickly generate that using peach B artisan to make test and let's call it API post

01:09.560 --> 01:11.530
comments test.

01:12.300 --> 01:16.150
And now let's find it inside the tests feature folder.

01:16.160 --> 01:22.490
So this is our brand new test let's close all this windows for time bang and you can see this has added

01:22.520 --> 01:23.470
an additional test.

01:23.480 --> 01:28.260
So when you rerun your test suite you should have one more assertion.

01:28.820 --> 01:29.060
OK.

01:29.090 --> 01:30.690
So we have this class.

01:30.700 --> 01:35.960
Now let's actually implemented and see how we can test our Jason API.

01:36.140 --> 01:44.150
Now since our tests for the API are functional tests they actually interact directly with our application

01:44.390 --> 01:47.390
and then they also interact with that database.

01:47.390 --> 01:54.080
What you should do is to first import our reference database straight which actually should have the

01:54.530 --> 01:58.170
use statement for already generated by Lavell.

01:58.310 --> 02:04.910
And what this does is it will reset our test database before each individual test is being run.

02:04.910 --> 02:07.260
So it's a very handy thing to have.

02:07.310 --> 02:13.600
Now let's go ahead and see how we can implement our first test so we don't need those comments here.

02:13.610 --> 02:17.030
And let's rename this test to actually have a meaningful name.

02:17.030 --> 02:22.120
So this would be test blog post or no test.

02:22.160 --> 02:32.150
New Blog Post does not have comments so you can guess what we'll be checking for.

02:32.150 --> 02:38.930
So we'll be checking if after adding a new blog post we won't have any comments listed because this

02:38.930 --> 02:40.970
is expected behavior.

02:40.970 --> 02:48.140
So now let's think I've said that before each test using a refreshed database trait will reset that

02:48.140 --> 02:48.910
as database.

02:48.920 --> 02:52.940
So we are starting with no blog post no user no nothing.

02:52.970 --> 02:55.250
So we have to create something first.

02:55.250 --> 02:59.350
So for that we can use factory function.

02:59.510 --> 03:06.870
And first we need to create a blog post mind that import that was added here.

03:07.280 --> 03:09.620
So we will create a new blog post

03:16.530 --> 03:22.590
so calling this that way won't work because as you might remember now each blog post actually has to

03:22.590 --> 03:24.420
have a user I.D. assigned.

03:24.450 --> 03:30.300
So we need to overwrite some values we can do that inside the array pass to the create method.

03:30.540 --> 03:34.510
And what you need to do is to parse the user I.D..

03:34.770 --> 03:41.790
Now we don't have to call the factory to create a new user since we have modified our base test case

03:41.790 --> 03:49.550
class before to contain a simple user method which you can use in all the classes that extend this based

03:49.550 --> 03:51.080
test case class.

03:51.240 --> 04:00.060
And this will just create a new user for us so we can just do this user which will generate a new user

04:00.060 --> 04:00.470
model.

04:00.540 --> 04:04.360
And from that model we'll get an I.D..

04:04.590 --> 04:06.790
So that's the first thing we'll have to do.

04:06.790 --> 04:15.220
And now how do we actually call our API so of course a lot of it comes with some handy methods to do

04:15.220 --> 04:18.940
this and the useful one is called Jason.

04:18.940 --> 04:23.810
So what you will do is you will call this Jason specify HDP verb.

04:23.830 --> 04:26.110
In our case this would beget.

04:26.530 --> 04:28.570
Then you have to specify the you url.

04:28.570 --> 04:35.200
So this would be the URL of this blog post and additionally if this is our post or put request you can

04:35.290 --> 04:44.670
add a body that would be sent as Jason then you can of course assert whether the TTP status code is

04:44.670 --> 04:50.780
expect that and there are some handy methods for checking Jason one of them is asset Jason which will

04:50.780 --> 04:56.950
check which would check if the Jason returned is exactly as we have specified here.

04:57.290 --> 05:03.580
Of course we specify it using BHP or race but Lavell will know how to compare that in this case.

05:03.590 --> 05:09.190
It's not really useful for it for us but well let's at least try the first part.

05:09.950 --> 05:22.140
So we have our response and we do this Jason our method is get and the end point is api v1.

05:22.210 --> 05:25.010
So we have the version 1.

05:25.180 --> 05:34.120
Then there is posts with Ida one and it is Ida 1 because we have just added a new blog post to an empty

05:34.120 --> 05:38.340
database and slash comments

05:41.460 --> 05:48.520
now we've made a call and now we can check if the response has the correct status.

05:48.560 --> 05:52.190
In this case this would be 200 OK.

05:52.190 --> 05:57.550
Now let's run it and we have 12 test for these assertions.

05:57.560 --> 06:01.070
So we have only one assertion right now in this class.

06:01.070 --> 06:02.340
And while it works.

06:02.350 --> 06:08.780
So we have just created a blog post and we are checking whether there is any response to this comment.

06:08.780 --> 06:11.050
Now if you do this you Earl.

06:11.240 --> 06:21.790
Now if you will comment this factory out and you will run this test you can see that we got a 404 error

06:21.790 --> 06:28.900
which means that this test is actual useful because if there is no blog post we've I.D. one which there

06:28.900 --> 06:29.470
isn't.

06:29.470 --> 06:35.590
After we have commented out this then of course there won't be anything under there slash comments you

06:35.630 --> 06:39.980
Earl.

06:40.360 --> 06:40.610
OK.

06:40.620 --> 06:43.770
So we have only checked so far for the status code.

06:43.770 --> 06:51.250
Now let's see how we can verify what would be inside this response so how can we verify if the data

06:51.330 --> 06:54.990
inside the response is actually what we want.

06:54.990 --> 06:59.120
So first let's see how the actual response looks like inside postman.

06:59.210 --> 07:04.340
So this is our API endpoint for blog post 1 with comments of course.

07:04.340 --> 07:10.180
Data comes from our application database not from the test database.

07:10.200 --> 07:16.740
So if you will make this request you can see that it actually starts with our data key which in this

07:16.740 --> 07:21.190
case won't contain anything in case of our test of course.

07:21.300 --> 07:26.750
And then at the bottom you have another section called links and then are meter section.

07:27.240 --> 07:35.760
So using the I said Jason call for this wouldn't make sense because we will actually have to verify

07:35.850 --> 07:42.180
all the exact values from this Jason responses as you can see it's quite big.

07:42.180 --> 07:44.580
There are some links to the pages.

07:44.580 --> 07:46.740
There are some meta information.

07:46.740 --> 07:55.410
So if you just want to check whether this is actually more or less correct what you expect you can use

07:55.410 --> 08:02.490
another method called assert Jason structure and inside it.

08:02.610 --> 08:15.230
It's just enough to start with an array and then we want to have the entries for data for links and

08:15.230 --> 08:16.860
for the meta

08:19.970 --> 08:27.250
so this might seem a little bit complicated but this is actually explained inside the documentation.

08:27.250 --> 08:34.240
So if you scroll a little bit to the down on this page you can see us or J some structure.

08:34.240 --> 08:40.900
And this is actually checking for the adjacent structure if it looks at how you'd like it.

08:40.900 --> 08:48.630
So it only checks whether a certain keys are actually inside the Jason response now.

08:48.640 --> 08:55.060
This method is not really very well documented inside the lateral documentation so let's see what actually

08:55.060 --> 08:56.380
happens here.

08:56.440 --> 09:00.290
So remember what how the top level response looks like.

09:01.390 --> 09:11.440
So it is an object and well in P we basically when we translate Jason to BHP code we use arrays for

09:11.440 --> 09:12.070
everything.

09:12.550 --> 09:21.820
So what we are doing here is we are checking whether the main object has a key called data has a key

09:21.820 --> 09:29.230
called links and then whether it has the key called meta which would actually match the Jason that his

09:29.230 --> 09:30.010
bank returns.

09:30.010 --> 09:35.110
So we have data here but we ignored what's inside.

09:35.110 --> 09:42.040
Then we have links we also ignore what's inside and then we have meta and we also ignore whatever is

09:42.130 --> 09:46.800
inside it so let's run this test.

09:48.420 --> 09:54.500
Okay so we have twelve tests for different assertions and it's green.

09:54.600 --> 09:59.910
So how can we be actually certain that there is nothing inside the data.

09:59.910 --> 10:06.650
So there is no not a single comment so we can also do that by not checking the whole Jason.

10:06.660 --> 10:07.740
Exactly.

10:07.740 --> 10:18.710
There is another method called assert J some count so we can verify that we want zero elements inside

10:18.950 --> 10:21.290
a data element.

10:21.380 --> 10:31.430
So how this works is it checks the key data and verifies if under this element there are zero elements.

10:31.610 --> 10:37.050
So let's go back to the response you can see that data is Jason array.

10:37.220 --> 10:40.470
It contains those objects and when there are no comments.

10:40.490 --> 10:45.480
Obviously this should be there should be zero inside.

10:45.500 --> 10:53.740
So let's run this test again and it's still green you can see for two free assertions now if you will

10:53.740 --> 11:01.120
check if there are like two elements then you can see that this test would break you can see that failed

11:01.480 --> 11:04.350
asserting that the actual size much is expected.

11:04.350 --> 11:08.250
Size 2 and of course the actual size is zero.

11:10.620 --> 11:16.840
Okay so this is how we can simply verify if you your Jason responses are the way you would like them

11:16.840 --> 11:17.640
to be.

11:17.680 --> 11:22.450
So let's go ahead and do a more complicated test in the next section.
